# Objectives
* Talk about the need of Big O Notation
* Describe Big O Notation
* Simplify Big O Expressions
* Define time and space complexity
* Evaluate time and space complexity of different algorithms
* Understand logarithms

## What are we doing here?
* We may have multiple implementations of the same function
* How would we determine what is best?
* Ex: "Write a function that accepts a string and nondestructive returns it reversed (return a copy)"
* There could be a whole bunch of approaches for the example question, but we need to have a system to classify and determine the best implementation

## But why do we care as long as it works?
* Depending on the project, that's true. Maybe the best solution is the first one you have.
* If you work at a larger company where they have huge swaths of data, performance really matters, and therefore the best solution using an algorithm exists.
* It is important to use the vocabulary and lingo when talking about our code performance.
* We can compare trade-offs of certain implmementations in actual code
* Inefficiencies of applications where it slows down or crashes can be easily identified
* ...which is why it can show up in interviews!